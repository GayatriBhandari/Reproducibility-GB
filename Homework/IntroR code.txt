#Assignment 2
#Intro R
#R as a calculator 

2 + 2  # returns 4
2 - 2  # returns 0
2/2  # returns 1
2 * 2  # returns 4
```


#For example, setting a atomic value (only one type = scalar) to an object (scalar object) we do this with the *<-* or *=* symbols.

x <- 2  
y = 3  


#So, here we *saved* the value of 2 to the letter x and the value 3 to the letter y. 

x + y  # returns 5
x - y  # returns -1
x/y  # returns 0.6666
x * y  # returns 6
```

#We can also save scalar objects with non-numeric data. For example, we can set an object equal to a character string by do this by putting it in quotes

name <- "GB"
seven <- "7"
```

#What if we try to add a character to a number? 

{r, error = TRUE}
seven + x


![ERROR! ERROR!](error-the-simpsons.gif)

#Will not work, R is a *smart* calculator

#But why!! Lets debug. We will do this with some functions. But first we need to know functions.

#Remember **objects**?

#Objects are manipulated with **functions** 



#For example, we will use the function `class()` to know what type of data is stored in the scalar objects `seven` and `x`. 

class(seven)
class(x)


#We can see that the output tells us that `seven` is a character type and `x` is a numeric type. Under the rules of R we cannot add a number to a character and this is why you get the error. 

#Ok now that we know what a function is we will introduce some new functions. 

#Lets use the `c()` function i.e. *concatenate function* to create a vector, or a bunch of scalar elements saved together in one **object**.
```{r}
vec <- c(1, 2, 3, 4, 5, 6, 7)  # numeric vector 
vec <- c(1:7)  # same numeric vector as above, the ':' (colon) generates a sequence
vec <- 1:7  # also works without the concatenate function
vec2 <- c("GB", "tara", "maya")  # character vector 
vec3 <- c(TRUE, FALSE, TRUE)  # logical vector
```

#We can index a vector by using brackets `[]`

vec2[2]  # returns the second element of vec2



vec + x  # will add the scalar x, elementwise to the vec object 


#We can also use some built in functions to calculate some basic summary stats

mean(vec)  # mean
sd(vec)  # standard deviation
sum(vec)  # sum
median(vec)  # median
min(vec)  # minimum 
max(vec)  # maximum
summary(vec)  #IQR - output depends on the data class

abs(vec) # absolute value
sqrt(vec) # square root (with subtraction)
log(vec) # natural log
log10(vec) # log base 10
exp(vec) # power of e
```

#R also understands logical operators

  - `>` greater than
  - `<` less than
  - `|` or
  - `&` and
  - `=` equals (used for assigning values from left to right)
  - `==` exactly equal (for showing equality between values)
  - `>=` greater than or equal
  - `!=` not equal to



#We can use logical operators to compare numbers

1 > 2 # greater than
1 < 2 # less than
1 <= 2 # less than or equal to
1 == 1 # equal to
1 == 2 | 1 == 1 # | means 'OR'
1 == 2 & 1 == 1 # & means 'AND' 
1 == 1 & 1 == 1
```

#We can also use logical operators to find things in objects

#Consider the following vector *t*, which is a numeric vector

t <- 1:10  # numeric vector


#We can find elements of *t* that fit our desire using logical operators

t[(t > 8) | (t < 5)]  # only the numbers that are greater than 8 or less than 5
t[(t > 8) & (t < 10)]  # returns 9
t[t != 2]  # returns elements of t that are not exactly equal to 2
t[!t == 2] # multiple ways to do the same thing


#We can also ask R to report back things. Like if a number exists in a vector.

1 %in% t


### Data types

#we will now explore more advanced data objects, we have already seen scalar and vector we will explore *matrices* and *dataframes*. Other data types like *lists* are useful for some purposes, but we will look at them later. 

#### Matrices

#a matrix is an atomic object, meaning it can only contain one data class, i.e.  numeric, character, or logical

#we can create a matrix by using the matrix function `matrix()`.  
#if we do not know how to use a function we can navigate to the help section or use the question mark `?` followed by the function name.  

#Example:
`?matrix`

#Lets create a matrix called `mat1` with 3 columns and 3 rows containing the values 1, 2, and 3

mat1 <- matrix(data = c(1, 2, 3), nrow = 3, ncol = 3)
mat1 # output mat1 to the console


#We can have character matricies too

mat2 <- matrix(data = c("GB", "tara", "maya"), nrow = 3, ncol = 3)
mat2 # output mat1 to the console



#We can transpose the matrix with the `t()` function.

t(mat2) # turns rows into columns and columns into rows


#Next lets practice indexing, or moving through, a matrix.

#We do this with brackets

mat2[1]  # returns the first element of the matrix i.e. row 1 column 1
mat2[2]  # returns the second element of the matrix i.e. row 2 column 1 
mat2[5]  # returns the 5th element of the matrix i.e. row 2 column 2
```


#R allows us to take a shortcut by specifying `[rows,columns]`

mat2[1, 3]  # returns the element in row 1 column 3


#if we leave the row or column space blank we will select

mat2[1, ]  # returns the first row 


#Now that we know matricies, dataframes are very similar, but a little more useful for our purposes because we can store different data types (i.e., classes) into a dataframe. Indexing works the same way, and with the `$`, which we will demonstrate below. 

#we can create a dataframe using the `data.frame()` function


df <- data.frame(mat1[,1], mat2[,1]) # created a data frame with the first columns of mat1 and mat2 and all rows
df # output to see in the console


#for the column headers so we can use the `colnames()` function to rename them

colnames(df) <- c("value", "name")
df


#lets work the the dataframe 

#indexing with data frames work the same as with matrices

df[1, ]  # returns the first row of the dataframe 
df[, "value"]  # returns the first column


#However, dataframes are awesome because we we can introduce a new and super easy way to index dataframes with the `$` opperator. 

df$value # outputs the entire column named value, the result is a vector
df$name # outputs the entire column named name, the result is a vector
df$name[2] # Brackets help us output the second value in our name column
df$name[2:3] # Brackets help us output the second through the third value in our name column with a colon.
```

#We can use the `str()` function to see the data classes stored in our data frame

str(df)


#We see we have a data frame with three observations and two variables. The varaibles are named *value* and *name*. *value* contains a numeric data class, where as *name* contains a character data class. 


#Since names is a character vector within the data frame R will also return a levels statement this just indicates the groups of your data. In other words we can subset our data. 


df$value[df$name == "tara"]  # returns 2, i.e. the element of var1 such that names = tara 
df[df$name == "tara",] # returns all rows with the value tara in the name column.


#there are multiple ways to do the same thing in R

#In this case we can also use the `subset()` function

subset(df, name == "tara") # returns the same thing as above


#We can add columns to a dataframe to create a new variable

df$log_value <- log(df$value) # create a new column with the column header named "log_value" and create this variable with the log of the "value" column
df


### INSTALLING PACKAGES


There are several ways to install a package, including from github, from R studio manually, from source. now using the `install.packages()` function. 


install.packages("ggplot2")  # use quotes around the package name



There are thousands of R packages already out there. 

- [dplyr](https://dplyr.tidyverse.org/)
- [ggplot2](https://ggplot2.tidyverse.org/)
- [purrr](https://purrr.tidyverse.org/)

All of the above packages (and some others) can be installed using one install called the tidyverse
- [tidyverse](https://www.tidyverse.org/)

More packages that are useful
- [lme4](https://github.com/lme4/lme4) for mixed linear models
- [emmeans](https://cran.r-project.org/web/packages/emmeans/index.html) for estimating marginal means


### Reading in data to R



We will work with .txt files or .csv files 

We can read in a .csv file with the `read.csv()` function by specifying the path to the file.

Now we can navigate to the filepath from our working directory to read in the data. 

csv <- read.csv("gb.csv", na.strings = "NA")



